# Project Development Guidelines (Cafe POS, Laravel 12 + Filament 4)

Audience: advanced Laravel developers working on this repository. Focus on project-specific setup, testing, and tooling decisions. Avoid committing secrets.

## 1) Build and Configuration

Prereqs

- PHP 8.2+ with required extensions (pdo_mysql, mbstring, openssl, gd, fileinfo)
- Composer
- Node.js 20+ and npm
- MySQL 5.7+/MariaDB 10.x (local), or use SQLite for quick testing

Initial setup (Windows PowerShell shown)

1. Install PHP deps
   - composer install
2. Environment files
   - Copy .env.example to .env and set the app URL/DB/mail/cache/queue settings
   - php artisan key:generate
   - php artisan storage:link
3. Database
   - Option A: Import provided schema/data (fast path)
     - mysql -u <user> -p <db> < cafe_pos.sql
   - Option B: Use migrations/seeders (if you add them)
     - php artisan migrate --seed
4. Frontend build
   - npm install
   - npm run build (or npm run dev for Vite DX)
5. Local dev processes (single multiplex command)
   - composer run dev
     - Starts: PHP server, queue listener, Pail logs, and Vite concurrently

Notes

- Filament 4 is installed along with several Filament plugins (Shield, Media Library plugin, date-range filter, etc.). Review their config before upgrades.
- Composer scripts include post events that publish assets and trigger filament:upgrade; this is intentional for local consistency.

## 2) Testing

Tooling

- PHPUnit ^11; configuration at phpunit.xml
- Test suites: Unit (tests/Unit), Feature (tests/Feature)
- Composer script: composer run test

Environments

- phpunit.xml sets APP_ENV=testing and uses array/cache/session/mail drivers for test runs.
- Important: Feature tests in this project hit application routes that query the database. Out of the box, without a configured test database, they will fail with 500s.

Recommended fast path for Feature tests

- Use in-memory SQLite for isolated tests. Update phpunit.xml (local-only):
  - DB_CONNECTION=sqlite
  - DB_DATABASE=:memory:
  - Provide an APP_KEY for test runs. Either add it to phpunit.xml, export it in your shell, or put it in .env.testing (recommended for local).
- Migrate the schema at test bootstrap or per test case using RefreshDatabase.
  - Example:
    - use Illuminate\Foundation\Testing\RefreshDatabase;
    - class SomeFeatureTest extends Tests\TestCase { use RefreshDatabase; ... }

Caveat: tests/TestCase.php

- The current Tests\TestCase extends Laravel's BaseTestCase but does not include CreatesApplication. Laravel 12â€™s BaseTestCase can still bootstrap via vendor/autoload, but for predictable app boot you should add:
  - use CreatesApplication; in Tests\TestCase and provide the trait (usually generated by the Laravel skeleton as tests/CreatesApplication.php pulling bootstrap/app.php). Consider adding this if you expand Feature tests.

Running tests (PowerShell)

- Full suite: vendor\bin\phpunit
- Unit only: vendor\bin\phpunit --testsuite Unit
- Single test file: vendor\bin\phpunit tests\Unit\YourTest.php
- Filter by test method: vendor\bin\phpunit --filter test_method_name

Adding a new test

1. Create tests/Unit/FooTest.php (for pure PHP logic) or tests/Feature/FooTest.php (for HTTP/DB interactions).
2. Prefer small, focused tests; avoid hard dependencies on seeded state. Use factories and RefreshDatabase for Feature tests.
3. Keep assertions explicit and meaningful; avoid broad catch-alls.

Demonstrated working example (validated during this update)

- We ran the Unit test suite successfully as a demonstration. Feature suite currently fails without DB setup because the home route queries the database.
  - Command executed: vendor\bin\phpunit --testsuite Unit
  - Result: OK (2 tests, 2 assertions) on PHP 8.3.16, PHPUnit 11.5.32

If you want Feature tests to pass locally

- Enable SQLite in-memory in phpunit.xml as above, or create a dedicated test database with MySQL and set DB_* vars in .env.testing
- Add minimal migrations/factories for entities used by your routes (e.g., products, categories) and use RefreshDatabase + factories in tests

Parallel testing

- If you introduce paratest later, ensure DB isolation (SQLite :memory: per process or testing database per process).

## 3) Code Style, Static Analysis, and Tooling

Code style

- Laravel Pint configured; run composer run lint or composer run cs
- Keep functions small, explicit naming; follow Laravel conventions for folders (Actions/Services, Policies, Resources)

Static analysis

- Larastan/PHPStan configured via phpstan.neon
  - Run: composer run stan
  - Start with levels that pass; increment only when green. Add baseline if necessary but prefer targeted fixes.

Frontend

- Vite 7 + Tailwind 4
- Scripts: npm run dev (serve), npm run build (production)
- Prettier configured with Blade and Tailwind plugins: npm run prettier

Security & operations

- No plaintext credentials in code or docs. Use .env, .env.testing, .env.staging, .env.production templates.
- roave/security-advisories is present; CI includes composer audit and npm audit (high severity) checks.
- For production: HTTPS, secure cookies, CSRF enabled; do not log sensitive fields.
- Health checks included via spatie/laravel-health; configure DB/cache/queue/disk/security-advisories checks.

## 4) App-specific Notes

- Filament plugins: be mindful of compatibility matrix when upgrading Laravel/Filament. Run @php artisan filament:upgrade after composer updates (scripted already).
- Database
  - Current README prefers importing cafe_pos.sql for a quick start. This means domain data exists outside migrations; consider migrating to proper migrations + seeders for better testability and CI reproducibility.
- Routes/views
  - The landing route queries products and categories; Feature tests that hit '/' require a database connection and schema. Plan tests accordingly.

## 5) Suggested Testing Baseline (to make Feature tests reliable)

- Add tests/CreatesApplication.php with standard Laravel bootstrap (if not present)
- Update tests/TestCase.php:
  - use CreatesApplication;
- Switch phpunit.xml to use SQLite in-memory for quick Feature tests; run migrations automatically with RefreshDatabase.
- Create minimal factories for frequently queried models (Product, Category) and use them in tests.

## 6) Typical Local Workflows

- Start everything: composer run dev
- Lint: composer run lint
- Static analysis: composer run stan
- Unit tests only (fast): vendor\bin\phpunit --testsuite Unit
- Build assets: npm run build

## 7) Git & Contribution

- Keep commits small and scoped; reference tasks from docs/tasks.md
- Avoid committing built assets and vendor; do commit config updates that affect reproducibility (phpunit.xml changes that improve test stability are acceptable)
- Never commit real secrets; templates only (.env.example, .env.staging, .env.production)
